import io
import time
from datetime import datetime, timedelta

from aiogram.types import CallbackQuery, BufferedInputFile
from aiogram.fsm.context import FSMContext

import plotly.graph_objects as go

from core.callbacks import Callbacks
from core.stage import Stage
from . import states, stages, repositories
from modules.calendar.handlers import start_period_picker
from ..expenses.models import Expense
from ..incomes.models import Income


MAX_MSG_LEN = 3500


async def analytics_menu_handler(cb: CallbackQuery, state: FSMContext) -> None:
    await cb.message.edit_text(
        stages.MENU.msg(),
        reply_markup=stages.MENU.kb(),
    )


async def analytics_stats_handler(cb: CallbackQuery, state: FSMContext) -> None:
    await cb.message.edit_text(
        stages.STATS_MENU.msg(),
        reply_markup=stages.STATS_MENU.kb(),
    )
    await state.set_state(states.AnalyticsStatesGroup.STATS_MENU)


async def analytics_stats_category_pie_start_picker_handler(cb: CallbackQuery, state: FSMContext) -> None:
    await start_period_picker(cb, state, target_state=states.AnalyticsStatesGroup.STATS_CATEGORY_PIE)


async def analytics_stats_category_pie_period_confirm_handler(cb: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    await state.clear()
    await send_pie_chart_callback(cb, data['date_period']['start'], data['date_period']['end'])
    await cb.message.answer(
        stages.STATS_MENU.msg(),
        reply_markup=stages.STATS_MENU.kb(),
    )
    await state.set_state(states.AnalyticsStatesGroup.STATS_MENU)


async def analytics_stats_income_expense_line_start_picker_handler(cb: CallbackQuery, state: FSMContext) -> None:
    await start_period_picker(cb, state, target_state=states.AnalyticsStatesGroup.STATS_INCOME_EXPENSE_LINE)


async def analytics_stats_income_expense_line_period_confirm_handler(cb: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    await state.clear()
    await send_income_expense_line_chart_callback(cb, data['date_period']['start'], data['date_period']['end'])
    await cb.message.answer(
        stages.STATS_MENU.msg(),
        reply_markup=stages.STATS_MENU.kb(),
    )
    await state.set_state(states.AnalyticsStatesGroup.STATS_MENU)


async def analytics_stats_summary_period_start_picker_handler(cb: CallbackQuery, state: FSMContext) -> None:
    """
    –ó–∞–ø—É—Å–∫–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å –≤—ã–±–æ—Ä–∞ –ø–µ—Ä–∏–æ–¥–∞ (–¥–∞—Ç–∞-—Ä–µ–ø–∏–∫–µ—Ä).
    """
    await start_period_picker(cb, state, target_state=states.AnalyticsStatesGroup.STATS_SUMMARY)


async def analytics_stats_summary_period_confirm_handler(cb: CallbackQuery, state: FSMContext) -> None:
    """
    –ü–æ–ª—É—á–∞–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∏—Ç–æ–≥–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é.
    """
    data = await state.get_data()
    await state.clear()

    start_date: datetime.date = data.get("date_period", {}).get("start")
    end_date: datetime.date = data.get("date_period", {}).get("end")

    if not start_date or not end_date:
        await cb.message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –∑–∞–Ω–æ–≤–æ.")
        await cb.answer()
        return

    user_id = cb.from_user.id
    income_total, expense_total = await repositories.get_total_summary(user_id, start_date, end_date)

    balance = income_total - expense_total
    balance_sign = "‚ûï" if balance >= 0 else "‚ûñ"
    balance_color = "üü¢" if balance >= 0 else "üî¥"

    caption = (
        f"<b>üìÜ –ò—Ç–æ–≥–∏ –∑–∞ –ø–µ—Ä–∏–æ–¥</b>\n"
        f"<i>{start_date.strftime('%d.%m.%Y')} ‚Äì {end_date.strftime('%d.%m.%Y')}</i>\n\n"
        f"üü¢ <b>–î–æ—Ö–æ–¥—ã:</b> {int(income_total)} ‚ÇΩ\n"
        f"üî¥ <b>–†–∞—Å—Ö–æ–¥—ã:</b> {int(expense_total)} ‚ÇΩ\n"
        f"{balance_color} <b>–ë–∞–ª–∞–Ω—Å:</b> {balance_sign} {abs(int(balance))} ‚ÇΩ"
    )

    await cb.message.answer(caption)
    await cb.message.answer(
        stages.STATS_MENU.msg(),
        reply_markup=stages.STATS_MENU.kb(),
    )
    await state.set_state(states.AnalyticsStatesGroup.STATS_MENU)


async def send_pie_chart_callback(
    cb: CallbackQuery,
    start_date,
    end_date
) -> None:
    """
    –ü–æ–ª—É—á–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ —Ä–∞—Å—Ö–æ–¥–∞—Ö –∏ –¥–æ—Ö–æ–¥–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥,
    –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫—Ä—É–≥–æ–≤—ã–µ –¥–∏–∞–≥—Ä–∞–º–º—ã –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∏—Ö –ø–æ –æ—Ç–¥–µ–ª—å–Ω–æ—Å—Ç–∏.
    """
    def create_pie_chart(categories: list[str], amounts: list[float], title: str) -> go.Figure:
        fig = go.Figure(data=[go.Pie(labels=categories, values=amounts, hole=0)])
        fig.update_traces(textinfo='percent+label')
        fig.update_layout(title_text=title)
        return fig

    async def gen_caption(
        category_sums: list[tuple[str, float]],
        total_sum: float,
        start_date: datetime.date,
        end_date: datetime.date,
        is_income: bool
    ) -> str:
        label = "–î–æ—Ö–æ–¥—ã" if is_income else "–†–∞—Å—Ö–æ–¥—ã"
        emoji = "üü¢" if is_income else "üî¥"
        total_emoji = "üí∞" if is_income else "üí∏"

        caption = (
            f"<b>üìä {label} –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º</b>\n"
            f"<i>—Å {start_date.strftime('%d.%m.%Y')} –ø–æ {end_date.strftime('%d.%m.%Y')}</i>\n\n"
        )
        for name, amount in category_sums:
            caption += f"‚Ä¢ <b>{name}</b>: {int(amount)} ‚ÇΩ\n"
        caption += f"\n<b>{total_emoji} –û–±—â–∞—è —Å—É–º–º–∞:</b> {int(total_sum)} ‚ÇΩ"
        return caption

    for is_income in (False, True):  # –°–Ω–∞—á–∞–ª–∞ —Ä–∞—Å—Ö–æ–¥—ã, –ø–æ—Ç–æ–º –¥–æ—Ö–æ–¥—ã
        category_sums, total_sum = await repositories.get_category_summary(
            cb.from_user.id, start_date, end_date, is_income=is_income
        )

        if not category_sums:
            await cb.message.answer(
                "–î–æ—Ö–æ–¥–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ." if is_income else "–†–∞—Å—Ö–æ–¥–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ."
            )
            continue

        categories, amounts = zip(*category_sums)
        fig = create_pie_chart(
            list(categories), list(amounts),
            title="–î–æ—Ö–æ–¥—ã –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º" if is_income else "–†–∞—Å—Ö–æ–¥—ã –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º"
        )

        buf = io.BytesIO(fig.to_image(format='png'))
        buf.seek(0)
        filename = f"chart_{'income' if is_income else 'expense'}_{int(time.time())}.png"
        photo = BufferedInputFile(buf.read(), filename=filename)
        caption = await gen_caption(category_sums, total_sum, start_date, end_date, is_income)

        await cb.message.answer_photo(photo=photo, caption=caption)

    await cb.answer()


async def send_income_expense_line_chart_callback(
    cb: CallbackQuery,
    start_date,
    end_date
) -> None:
    """
    –ü–æ–ª—É—á–∞–µ—Ç –¥–æ—Ö–æ–¥—ã –∏ —Ä–∞—Å—Ö–æ–¥—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∑–∞ –ø–µ—Ä–∏–æ–¥, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ª–∏–Ω–µ–π–Ω—ã–π –≥—Ä–∞—Ñ–∏–∫ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –µ–≥–æ.

    Args:
        cb (CallbackQuery): callback-–∑–∞–ø—Ä–æ—Å –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Telegram.
        start_date (datetime.date): –¥–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ –ø–µ—Ä–∏–æ–¥–∞.
        end_date (datetime.date): –¥–∞—Ç–∞ –∫–æ–Ω—Ü–∞ –ø–µ—Ä–∏–æ–¥–∞.

    Returns:
        None
    """
    def create_income_expense_line_chart(dates: list[str], incomes: list[float], expenses: list[float]) -> go.Figure:
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=dates, y=incomes, mode='lines+markers', name='–î–æ—Ö–æ–¥—ã', line=dict(color='green')))
        fig.add_trace(go.Scatter(x=dates, y=expenses, mode='lines+markers', name='–†–∞—Å—Ö–æ–¥—ã', line=dict(color='red')))
        fig.update_layout(title='–î–æ—Ö–æ–¥—ã –∏ —Ä–∞—Å—Ö–æ–¥—ã –ø–æ –¥–Ω—è–º', xaxis_title='–î–∞—Ç–∞', yaxis_title='–°—É–º–º–∞, ‚ÇΩ')
        return fig

    income_data, expense_data = await repositories.get_income_and_expense_by_day(cb.from_user.id, start_date, end_date)

    if not income_data and not expense_data:
        await cb.message.answer("–ó–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –¥–∞–Ω–Ω—ã—Ö –æ –¥–æ—Ö–æ–¥–∞—Ö –∏ —Ä–∞—Å—Ö–æ–¥–∞—Ö –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        await cb.answer()
        return

    # –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–∞—Ç –≤ –ø–µ—Ä–∏–æ–¥–µ (—á—Ç–æ–±—ã –≥—Ä–∞—Ñ–∏–∫ –±—ã–ª —Ä–æ–≤–Ω—ã–π)
    all_dates = sorted(set(income_data.keys()) | set(expense_data.keys()))
    dates_str = [d.strftime('%d.%m.%Y') for d in all_dates]
    incomes = [income_data.get(d, 0) for d in all_dates]
    expenses = [expense_data.get(d, 0) for d in all_dates]

    fig = create_income_expense_line_chart(dates_str, incomes, expenses)
    buf = io.BytesIO(fig.to_image(format='png'))
    buf.seek(0)
    filename = f"income_expense_{int(time.time())}.png"
    photo = BufferedInputFile(buf.read(), filename=filename)

    caption = (
        f"<b>üìà –î–æ—Ö–æ–¥—ã –∏ —Ä–∞—Å—Ö–æ–¥—ã</b>\n"
        f"<i>—Å {start_date.strftime('%d.%m.%Y')} –ø–æ {end_date.strftime('%d.%m.%Y')}</i>"
    )

    await cb.message.answer_photo(photo=photo, caption=caption)
    await cb.answer()


async def analytics_history_handler(cb: CallbackQuery, state: FSMContext) -> None:
    await cb.message.edit_text(
        stages.HISTORY_MENU.msg(),
        reply_markup=stages.HISTORY_MENU.kb(),
    )
    await state.set_state(states.AnalyticsStatesGroup.HISTORY_MENU)


async def analytics_history_period_handler(cb: CallbackQuery, state: FSMContext) -> None:
    if cb.data == Callbacks.ANALYTICS.HISTORY.PERIOD:
        await start_period_picker(cb, state, target_state=states.AnalyticsStatesGroup.HISTORY_PERIOD)
    else:
        start_date = datetime.now() - timedelta(
            days=1) if cb.data == Callbacks.ANALYTICS.HISTORY.LAST_DAY else datetime.now() - timedelta(days=7)
        end_date = datetime.now()
        await show_operations_history(cb, cb.from_user.id, start_date, end_date)
        await state.set_state(states.AnalyticsStatesGroup.HISTORY_MENU)


async def analytics_history_period_confirm_handler(cb: CallbackQuery, state: FSMContext) -> None:
    data = await state.get_data()
    await state.clear()

    start_date: datetime = data.get("date_period", {}).get("start")
    end_date: datetime = data.get("date_period", {}).get("end")

    await show_operations_history(cb, cb.from_user.id, start_date, end_date)
    await state.set_state(states.AnalyticsStatesGroup.HISTORY_MENU)


async def show_operations_history(
    cb: CallbackQuery,
    user_id: int,
    start_date: datetime,
    end_date: datetime
) -> None:
    operations = await repositories.get_incomes_expenses_for_period(
        user_id,
        start_date,
        end_date
    )

    history_messages = await format_operations_history(operations, start_date, end_date)
    for idx, msg in enumerate(history_messages):
        if idx == 0:
            await cb.message.answer(msg, parse_mode="HTML")
        else:
            await cb.message.answer(msg, parse_mode="HTML")

    await cb.message.answer(
        "–£–∫–∞–∂–∏—Ç–µ –ø–µ—Ä–∏–æ–¥:",
        reply_markup=stages.HISTORY_MENU.kb()
    )


async def format_operations_history(
    operations: tuple[list[Income], list[Expense]],
    start_date: datetime,
    end_date: datetime
) -> list[str]:
    incomes, expenses = operations

    all_ops = sorted([*incomes, *expenses], key=lambda x: x.date, reverse=True)
    actual_start = min((op.date for op in all_ops), default=start_date)
    actual_end = max((op.date for op in all_ops), default=end_date)

    def format_income(income: Income) -> str:
        category = getattr(getattr(income, 'category', None), 'name', '–ë–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏')
        date_str = income.date.strftime('%d.%m.%Y %H:%M')
        comment = f"\n<i>üìù {income.comment}</i>" if income.comment else ""

        return (
            f"<b>üí∞ +{income.amount} ‚ÇΩ</b>  <u>{category}</u>\n"
            f"<b>üìÖ</b> <code>{date_str}</code>{comment}\n"
        )

    def format_expense(expense: Expense) -> str:
        category = getattr(getattr(expense, 'category', None), 'name', '–ë–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏')
        date_str = expense.date.strftime('%d.%m.%Y %H:%M')
        comment = f"\n<i>üìù {expense.comment}</i>" if expense.comment else ""

        return (
            f"<b>üîª -{expense.amount} ‚ÇΩ</b>  <u>{category}</u>\n"
            f"<b>üìÖ</b> <code>{date_str}</code>{comment}\n"
        )

    total_income = sum(income.amount for income in incomes)
    total_expense = sum(exp.amount for exp in expenses)
    balance = total_income - total_expense

    header = [
        "üìä <b>–ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π</b>",
        f"üìÖ –ü–µ—Ä–∏–æ–¥: <code>{actual_start.strftime('%d.%m.%Y')}</code> ‚Äî <code>{actual_end.strftime('%d.%m.%Y')}</code>",
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
    ]

    # –ù–∞—á–∏–Ω–∞–µ–º —Å –∑–∞–≥–æ–ª–æ–≤–∫–∞ –∏ –¥–æ—Ö–æ–¥–æ–≤
    message_chunks: list[str] = []
    current_message = "\n".join(header)

    # –î–æ–±–∞–≤–ª—è–µ–º –±–ª–æ–∫ –¥–æ—Ö–æ–¥–æ–≤
    income_header = f"üìà <b>–î–æ—Ö–æ–¥—ã ({len(incomes)})</b>" if incomes else "üìà <b>–î–æ—Ö–æ–¥–æ–≤ –Ω–µ—Ç</b>"
    income_lines = [income_header]
    if incomes:
        for income in incomes:
            income_lines.append(format_income(income))

    # –î–æ–±–∞–≤–ª—è–µ–º –¥–æ—Ö–æ–¥—ã –ø–æ—Å—Ç—Ä–æ—á–Ω–æ
    for line in income_lines + ["‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"]:
        if len(current_message) + len(line) + 1 > MAX_MSG_LEN:
            message_chunks.append(current_message)
            current_message = ""
        current_message += f"\n{line}"

    # –†–∞—Å—Ö–æ–¥—ã
    expense_header = f"üìâ <b>–†–∞—Å—Ö–æ–¥—ã ({len(expenses)})</b>" if expenses else "üìâ <b>–†–∞—Å—Ö–æ–¥–æ–≤ –Ω–µ—Ç</b>"
    expense_lines = [expense_header]
    if expenses:
        for expense in expenses:
            expense_lines.append(format_expense(expense))

    for line in expense_lines + ["‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"]:
        if len(current_message) + len(line) + 1 > MAX_MSG_LEN:
            message_chunks.append(current_message)
            current_message = ""
        current_message += f"\n{line}"

    # –ò—Ç–æ–≥–æ–≤—ã–π –±–ª–æ–∫
    footer_lines = [
        f"üíµ <b>–ò—Ç–æ–≥–æ –¥–æ—Ö–æ–¥—ã:</b> <b>+{total_income} ‚ÇΩ</b>" if incomes else "",
        f"üí∏ <b>–ò—Ç–æ–≥–æ —Ä–∞—Å—Ö–æ–¥—ã:</b> <b>-{total_expense} ‚ÇΩ</b>" if expenses else "",
        f"üßÆ <b>–ë–∞–ª–∞–Ω—Å:</b> <b>{'+' if balance >= 0 else ''}{balance} ‚ÇΩ</b>",
        f"üìå <b>–í—Å–µ–≥–æ –æ–ø–µ—Ä–∞—Ü–∏–π:</b> <b>{len(incomes) + len(expenses)}</b>",
    ]

    for line in filter(None, footer_lines):
        if len(current_message) + len(line) + 1 > MAX_MSG_LEN:
            message_chunks.append(current_message)
            current_message = ""
        current_message += f"\n{line}"

    if current_message.strip():
        message_chunks.append(current_message)

    return message_chunks
